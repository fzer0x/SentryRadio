package dev.fzer0x.imsicatcherdetector2.security

import android.content.Context
import dev.fzer0x.imsicatcherdetector2.data.ForensicDatabase
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class VulnerabilityManager(context: Context) {
    private val forensicDao = ForensicDatabase.getDatabase(context).forensicDao()
    private val nvdService = NvdCveService() // Hier könnte man einen API-Key übergeben

    suspend fun checkVulnerabilities(
        chipset: String,
        baseband: String,
        securityPatch: String
    ): List<CveEntry> = withContext(Dispatchers.IO) {
        
        // 1. Lade Cache
        var cachedEntities = forensicDao.getAllCves()
        val oneDayAgo = System.currentTimeMillis() - (24 * 60 * 60 * 1000)

        // 2. Update Cache falls nötig (1x täglich oder wenn leer)
        if (cachedEntities.isEmpty() || cachedEntities.any { it.lastUpdated < oneDayAgo }) {
            val freshCves = nvdService.fetchCurrentVulnerabilities()
            if (freshCves.isNotEmpty()) {
                val entities = freshCves.map { 
                    CveEntity(
                        cveId = it.cveId, 
                        description = it.description, 
                        severity = it.severity, 
                        publishedDate = it.publishedDate, 
                        productsSerialized = "", // Optional: CPE Strings speichern
                        lastUpdated = System.currentTimeMillis()
                    ) 
                }
                forensicDao.insertCves(entities)
                cachedEntities = entities
            }
        }

        // 3. Konvertiere Entities in Domain Modelle und Filtern
        cachedEntities.map { entity ->
            CveEntry(
                cveId = entity.cveId,
                description = entity.description,
                severity = entity.severity,
                publishedDate = entity.publishedDate,
                isRelevantForImsiCatcher = entity.description.lowercase().contains(Regex("nas|rrc|protocol|downgrade|unencrypted|cipher"))
            )
        }.filter { cve ->
            // Match Chipset oder Baseband in der Beschreibung
            val chipMatch = VulnerabilityMatcher.isChipsetAffected(cve.description, chipset) ||
                            VulnerabilityMatcher.isChipsetAffected(cve.description, baseband)
            
            // Match Patch Level (nur CVEs zeigen, die nach dem Patch veröffentlicht wurden)
            val isUnpatched = VulnerabilityMatcher.isVulnerable(cve, securityPatch)

            chipMatch && isUnpatched
        }.sortedByDescending { it.severity }
    }
}
