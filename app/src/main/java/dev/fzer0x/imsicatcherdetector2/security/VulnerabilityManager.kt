package dev.fzer0x.imsicatcherdetector2.security

import android.content.Context
import android.util.Log
import dev.fzer0x.imsicatcherdetector2.data.ForensicDatabase
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class VulnerabilityManager(context: Context) {
    private val forensicDao = ForensicDatabase.getDatabase(context).forensicDao()
    private val nvdService = NvdCveService() // Hier könnte man einen API-Key übergeben

    suspend fun checkVulnerabilities(
        chipset: String,
        baseband: String,
        securityPatch: String,
        forceRefresh: Boolean = false
    ): Pair<List<CveEntry>, Pair<Int, Int>> = withContext(Dispatchers.IO) {

        // 1. Lade Cache
        var cachedEntities = forensicDao.getAllCves()
        val oneDayAgo = System.currentTimeMillis() - (24 * 60 * 60 * 1000)

        // 2. Update Cache falls nötig (1x täglich oder wenn leer) oder forceRefresh
        if (cachedEntities.isEmpty() || cachedEntities.any { it.lastUpdated < oneDayAgo } || forceRefresh) {
            Log.d("VulnerabilityManager", "Updating CVE database (forceRefresh=$forceRefresh)")

            if (forceRefresh) {
                // Bei forceRefresh: komplette Datenbank leeren und neu aufbauen
                Log.d("VulnerabilityManager", "Force refresh: clearing entire cache")
                forensicDao.clearCves()
                cachedEntities = emptyList()
            }

            // Hole aktuelle CVEs von der API
            val freshCves = nvdService.fetchCurrentVulnerabilities()
            if (freshCves.isNotEmpty()) {
                if (forceRefresh || cachedEntities.isEmpty()) {
                    // Kompletter Neuaufbau der Datenbank
                    Log.d("VulnerabilityManager", "Building complete CVE database with ${freshCves.size} entries")
                    val entities = freshCves.map {
                        CveEntity(
                            cveId = it.cveId,
                            description = it.description,
                            severity = it.severity,
                            publishedDate = it.publishedDate,
                            productsSerialized = "", // Optional: CPE Strings speichern
                            lastUpdated = System.currentTimeMillis()
                        )
                    }
                    forensicDao.insertCves(entities)
                    cachedEntities = entities
                    Log.d("VulnerabilityManager", "Inserted ${entities.size} fresh CVEs into database")
                } else {
                    // Inkrementelles Update: nur neue CVEs hinzufügen
                    val existingCveIds = forensicDao.getAllCveIds().toSet()
                    val newCves = freshCves.filter { it.cveId !in existingCveIds }

                    if (newCves.isNotEmpty()) {
                        Log.d("VulnerabilityManager", "Incremental update: adding ${newCves.size} new CVEs")
                        val newEntities = newCves.map {
                            CveEntity(
                                cveId = it.cveId,
                                description = it.description,
                                severity = it.severity,
                                publishedDate = it.publishedDate,
                                productsSerialized = "",
                                lastUpdated = System.currentTimeMillis()
                            )
                        }
                        forensicDao.insertCves(newEntities)
                        Log.d("VulnerabilityManager", "Added ${newEntities.size} new CVEs to existing database")
                    } else {
                        Log.d("VulnerabilityManager", "No new CVEs found, keeping existing cache")
                    }

                    // Lade aktualisierten Cache
                    cachedEntities = forensicDao.getAllCves()
                }
            }
        } else {
            Log.d("VulnerabilityManager", "Using cached CVEs (${cachedEntities.size} entries)")
        }

        // 3. Konvertiere Entities in Domain Modelle
        val allCves = cachedEntities.map { entity ->
            CveEntry(
                cveId = entity.cveId,
                description = entity.description,
                severity = entity.severity,
                publishedDate = entity.publishedDate,
                isRelevantForImsiCatcher = entity.description.lowercase().contains(Regex("nas|rrc|protocol|downgrade|unencrypted|cipher"))
            )
        }

        // 4. Zähle Gesamt-CVEs und chipset-spezifische CVEs
        val totalCveCount = allCves.size
        val chipsetCveCount = allCves.count { cve ->
            VulnerabilityMatcher.isChipsetAffected(cve.description, chipset) ||
                    VulnerabilityMatcher.isChipsetAffected(cve.description, baseband)
        }

        // 5. Filtern nach relevanten CVEs für das Gerät
        val filteredCves = allCves.filter { cve ->
            // Match Chipset oder Baseband in der Beschreibung
            val chipMatch = VulnerabilityMatcher.isChipsetAffected(cve.description, chipset) ||
                    VulnerabilityMatcher.isChipsetAffected(cve.description, baseband)

            // Match Patch Level (nur CVEs zeigen, die nach dem Patch veröffentlicht wurden)
            val isUnpatched = VulnerabilityMatcher.isVulnerable(cve, securityPatch)

            chipMatch && isUnpatched
        }.sortedByDescending { it.severity }

        Pair(filteredCves, Pair(totalCveCount, chipsetCveCount))
    }
}